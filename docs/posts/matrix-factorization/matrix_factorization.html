<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="chris">
<meta name="dcterms.date" content="2024-01-25">

<title>cbhyphen.github.io - Matrix Factorization for Recommender Systems</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">cbhyphen.github.io</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">about</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/cbhyphen" rel="" target=""><i class="bi bi-github" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Matrix Factorization for Recommender Systems</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>chris </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 25, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>It’d be pretty difficult to have escaped recommender systems in 2024 unless you live somewhere without internet (and in which case you wouldn’t be reading this anyways). We get recommended content from streaming services like Netflix and products from online shopping platforms like Amazon. Built-in ads recommend products even when we’re not trying to shop for anything. Even if you don’t know the term recommender systems, there’s a good chance you understand what it does.</p>
<p>I first heard about recommender systems early in my data science journey and in the context of the Netflix prize.</p>
<p>https://en.wikipedia.org/wiki/Netflix_Prize</p>
<p>The netflix prize was a competition for the best collaboratize filtering algorithm to predict user ratings for movies.</p>
<p>A brief history of recommender systems https://arxiv.org/abs/2209.01860 suggests that some of the earliest collaborative filtering algorithms were nearest neighbor techniques followed by matrix factorization, the later of which was used extensively during the Netflix Prize…</p>
<p>https://en.wikipedia.org/wiki/Matrix_factorization_(recommender_systems)</p>
<p>mention content based filtering (using user features in a classification or regression model to predict what they might like)</p>
<p>The winners of the prize proved that matrix factorization models (type of colaborative filtering) were far superior.</p>
<p>in my research of matrix factorization methods, probabilistic matrix factorization (PMF) came up as a seminal improvement over previous MF techniques</p>
<p>https://proceedings.neurips.cc/paper_files/paper/2007/file/d7322ed717dedf1eb4e6e52a37ea7bcd-Paper.pdf</p>
<p>have not used MF for machine learning…</p>
<p>came up even in the PyMC package..</p>
<p>https://www.pymc.io/projects/examples/en/latest/case_studies/probabilistic_matrix_factorization.html#id4</p>
<p>sparse matrices don’t allow for SVD methods… regularization penalties aren’t practical for large datasets (i.e.&nbsp;millions of observations)… PMF scales linearly with the number of observations..</p>
<p>some intuition…</p>
<p>imagine you have m users and some number of n movies. you can represent this with a an (m x n) matrix and the values of the matrix indicate the ranking a person gave to the movie. for simplicity, let’s say the value is 1 if they watched it and hit thumbs up, otherwise it’s a zero.</p>
<p>of course, not everyone is going to watch every single movie available so there will be missing values in the matrix. but in order to keep users on the platform, we should be able to recommend good movies they haven’t watched otherwise they’ll go somewhere else.</p>
<p>before getting to the idea behind matrix factorization, let’s say that each user can be described by the vector of movies they liked. this is similar to how words represented by an embedding vector. if certain people have similar preferences, then their vectors will be similar (measured by cosine similarity for example).</p>
<p>ok so, users can be described by their vector of movie preferences. but because there is some similarity in movies, we could probably condense this vector representation into a lower dimensional space (ie &lt;&lt; n) and still approximately describe the same person. that lower dimensional space can be thought of as movie basis vectors.</p>
<p>in the same way we can describe people by the movies they like, we can also describe movies by the people that like them. usually I’m against stereotypes but I’ll go ahead and say some people are just similar (fix). so we can also condense the movie representation into a smaller space of people basis vectors. this sounds a lot like SVD/PCA…</p>
<p>back to this (m x n) matrix of users and movies. just from a dimensionality perspective, it’s clear that the product of two smaller matrices (say m x d and d x n) could be used to represent this larger m x n matrix. using these two smaller matrices make it easier for us to make educated guesses about the vectors that describe users or movies since they have a smaller dimensionality (d &lt;&lt; m and d &lt;&lt; n). it’s important to note that the product of these matrices is just an approximation, so there is some error involved. but we can minimize this error in an optimization process similar to gradient descent.</p>
<p>so at a high level, that’s exactly what we’re doing here with matrix factorization. the benefit of this is that once we’ve reached a good guess for (call it matrix U and matrix V) the matrices, then we can use those to impute/predict values for the original matrix. If an imputed value is a 1 (ie they will probably thumbs up it), then we can recommend it to that user.</p>
<p>show formula for approximation matrix, etc. derivation of why MAP is better than MLE (sparsity)?</p>
<p>and now for some notation…</p>
<p>we have <span class="math inline">\(n\)</span> users and <span class="math inline">\(m\)</span> movies and a ratings matrix <span class="math inline">\(R \in \mathbb{R}^{m \times n}\)</span> such that <span class="math inline">\(R_{i,j}\)</span> is the rating by user <span class="math inline">\(i\)</span> for movie <span class="math inline">\(j\)</span>. the user latent matrix is <span class="math inline">\(U \in \mathbb{R}^{d \times n}\)</span> and movie latent matrix <span class="math inline">\(V \in \mathbb{R}^{d \times m}\)</span> where <span class="math inline">\(d\)</span> is the latent space dimension and a tunable hyperparameter.</p>
<p>because <span class="math inline">\(R_{i,j}\)</span> is approximated by the product of latent vectors <span class="math inline">\(U_i\)</span> and <span class="math inline">\(V_j\)</span>, it is normally distributed with that mean and a specified variance</p>
<p><span class="math display">\[R_{i,j} \sim N(U_i^{\intercal} V_j, \sigma ^ 2)\]</span></p>
<p>the latent vectors <span class="math inline">\(U_i\)</span> and <span class="math inline">\(V_j\)</span> are also normally distributed with zero mean and but no covariance between features (dimensionality <span class="math inline">\(d\)</span>)</p>
<p><span class="math display">\[U_i \sim N(0, \sigma_u ^ 2 \mathbf{I})\]</span></p>
<p><span class="math display">\[V_j \sim N(0, \sigma_v ^ 2 \mathbf{I})\]</span></p>
<p>the likelihood function</p>
<p><span class="math display">\[
p(R|U,V,\sigma^2) = \prod\limits_{i}^{n}\prod\limits_{j}^{m} p(R_{i,j} | U_i, V_j)
\]</span></p>
<p>and prior probabilities (latent matrices)</p>
<p><span class="math display">\[
p(U|\sigma_u^2) = \prod\limits_{i}^{n} p(U_i) \; , \quad p(V|\sigma_v^2) = \prod\limits_j^m p(V_i)
\]</span></p>
<p>whose product define the posterior distribution. the MAP solution for this involves taking the log probability of the posterior (see paper) which ultimately results in the following objective function that we want to minimize</p>
<p><span class="math display">\[
E = \frac{1}{2} \sum_i^n \sum_j^m I_{i,j}(R_{i,j} - U_i^\intercal V_j)^2 + \frac{\lambda_u}{2} \sum_i^n \Vert U_i \Vert ^ 2 +  \frac{\lambda_v}{2} \sum_j^m \Vert V_j \Vert ^ 2
\]</span></p>
<p>where <span class="math inline">\(I_{i,j}\)</span> is an indicator function if user <span class="math inline">\(i\)</span> has rated movie <span class="math inline">\(j\)</span>, <span class="math inline">\(\lambda_u = \frac{\sigma^2}{\sigma_u^2}\)</span> and <span class="math inline">\(\lambda_v = \frac{\sigma^2}{\sigma_v^2}\)</span>.</p>
<p>The paper defines this objective function but doesn’t go into much detail about the optimization procedure. Because there are two unknown matrices, we need to perform an alternating gradient descent (also known as alternating least squares). This involves holding either of the latent matrices constant while the other is updated. See here and here for more detail.</p>
<p>https://engineering.fb.com/2015/06/02/core-infra/recommending-items-to-more-than-a-billion-people/</p>
<p>https://developers.google.com/machine-learning/recommendation/collaborative/matrix</p>
<p>To find the update rules, we need to find partial derivatives for <span class="math inline">\(U_i\)</span> and <span class="math inline">\(V_j\)</span> with respect to the objective function defined in the paper. So time to dive into some matrix calculus. Below is my derivation for <span class="math inline">\(\frac{\partial E}{\partial U_i}\)</span> … note that my notation is pretty loose</p>
<p><span class="math display">\[
\frac{\partial}{\partial U_i} \biggl[ \frac{1}{2}\sum_i^n \sum_j^m I_{i,j}(R_{i,j} - U_i^\intercal V_j)^2 \biggr] + \frac{\partial}{\partial U_i} \biggl[ \frac{\lambda_u}{2} \sum_i^n \Vert U_i \Vert ^ 2 \biggr] + \frac{\partial}{\partial U_i} \biggl[ \frac{\lambda_v}{2} \sum_j^m \Vert V_j \Vert ^ 2 \biggr]
\]</span></p>
<p>summation over <span class="math inline">\(i\)</span> dissappears as there is only one term that is not a constant when differentiating with respect to <span class="math inline">\(U_i\)</span> and we set to zero since we are trying to minimize a convex function</p>
<p><span class="math display">\[
\lambda_u U_i - \sum_j^m I_{i,j}(R_{i,j} - U_i^\intercal V_j) V_j = 0
\]</span></p>
<p><span class="math display">\[
\lambda_u U_i - \sum_j^m I_{i,j} R_{i,j} V_j + U_i \sum_j^m I_{i,j} V_j V_j^\intercal = 0
\]</span></p>
<p>solving for <span class="math inline">\(U_i\)</span></p>
<p><span class="math display">\[
U_i \biggl( \lambda_u \mathbf{I} + \sum_j^m I_{i,j} V_j V_j^\intercal \biggr) = \sum_j^m I_{i,j} R_{i,j} V_j
\]</span></p>
<p><span class="math display">\[
U_i = \sum_j^m I_{i,j} R_{i,j} V_j \biggl( \lambda_u \mathbf{I} + \sum_j^m I_{i,j} V_j V_j^\intercal \biggr)^{-1}
\]</span></p>
<p>and it follows similarly for <span class="math inline">\(V_j\)</span></p>
<p><span class="math display">\[
V_j = \sum_i^n I_{i,j} R_{i,j} U_i \biggl(\lambda_v \mathbf{I} + \sum_i^n I_{i,j} U_i U_i^\intercal \biggr)^{-1}
\]</span></p>
<p>now we can perform alternating least squares optimization which entails updating one variable while holding the other constant and vice-versa…</p>
<ul>
<li>add algo/code for ALS optim</li>
<li>use the logistic function (i.e.&nbsp;sigmoid) to squash preds to [0, 1]</li>
<li>map preds to the ratings range and round to nearest</li>
<li>test on the movie lens dataset (or something smaller) and compare eval metrics with SOTA ?</li>
</ul>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>